import { PostCommentForPullRequestCommand } from "@aws-sdk/client-codecommit";
import { client } from "../codecommit/codecommitService.js";

/**
 * Post comment on specific line in file (appears in Changes tab)
 */
export async function postInlineFileComment({
  repositoryName,
  pullRequestId,
  beforeCommitId,
  afterCommitId,
  filePath,
  line,
  content
}) {
  try {
    const command = new PostCommentForPullRequestCommand({
      pullRequestId,
      repositoryName,
      beforeCommitId,
      afterCommitId,
      location: {
        filePath,
        filePosition: line, // 1-based line number
        relativeFileVersion: "AFTER" // Comment on the new version of the file
      },
      content
    });

    const response = await client.send(command);
    console.log(`💬 Inline comment posted to ${filePath} line ${line}`);
    return {
      success: true,
      commentId: response.comment?.commentId,
      filePath,
      line
    };
  } catch (err) {
    console.error(`❌ Failed to post inline comment to ${filePath} line ${line}:`, err.message);
    return {
      success: false,
      error: err.message,
      filePath,
      line
    };
  }
}

/**
 * Post comment on entire file (appears in Changes tab)
 */
export async function postFileComment({
  repositoryName,
  pullRequestId,
  beforeCommitId,
  afterCommitId,
  filePath,
  content
}) {
  try {
    const command = new PostCommentForPullRequestCommand({
      pullRequestId,
      repositoryName,
      beforeCommitId,
      afterCommitId,
      location: {
        filePath,
        filePosition: 1, // Start of file
        relativeFileVersion: "AFTER"
      },
      content
    });

    const response = await client.send(command);
    console.log(`💬 File comment posted to ${filePath}`);
    return {
      success: true,
      commentId: response.comment?.commentId,
      filePath
    };
  } catch (err) {
    console.error(`❌ Failed to post file comment to ${filePath}:`, err.message);
    return {
      success: false,
      error: err.message,
      filePath
    };
  }
}

/**
 * Post AI analysis as inline comment on file (will appear in Changes tab)
 */
export async function postAIAnalysisComment({
  repositoryName,
  pullRequestId,
  beforeCommitId,
  afterCommitId,
  filePath,
  aiAnalysis
}) {
  const content = `## 🤖 AI Code Review: \`${filePath}\`\n\n${aiAnalysis}\n\n---\n*Generated by AI Code Reviewer*`;
  
  // Post as file comment (line 1) to appear in Changes tab
  return await postFileComment({
    repositoryName,
    pullRequestId,
    beforeCommitId,
    afterCommitId,
    filePath,
    content
  });
}

/**
 * Post multiple targeted comments for specific issues
 */
export async function postTargetedComments({
  repositoryName,
  pullRequestId,
  beforeCommitId,
  afterCommitId,
  filePath,
  issues
}) {
  const results = [];
  
  for (const issue of issues) {
    const result = await postInlineFileComment({
      repositoryName,
      pullRequestId,
      beforeCommitId,
      afterCommitId,
      filePath,
      line: issue.line || 1,
      content: `🔍 **${issue.type}**: ${issue.message}`
    });
    results.push(result);
  }
  
  return results;
}

/**
 * Analyze content and post targeted comments on specific lines
 */
export async function postSmartAIComments({
  repositoryName,
  pullRequestId,
  beforeCommitId,
  afterCommitId,
  filePath,
  aiAnalysis,
  fileContent
}) {
  const results = [];
  
  // Extract specific issues from AI analysis
  const issues = extractIssuesFromAnalysis(aiAnalysis, fileContent);
  
  // Post main AI analysis comment
  const mainComment = await postFileComment({
    repositoryName,
    pullRequestId,
    beforeCommitId,
    afterCommitId,
    filePath,
    content: `## 🤖 AI Code Review Summary\n\n${aiAnalysis}\n\n---\n*Generated by AI Code Reviewer*`
  });
  results.push(mainComment);
  
  // Post specific issue comments on relevant lines
  for (const issue of issues.slice(0, 3)) { // Limit to 3 specific comments
    const issueComment = await postInlineFileComment({
      repositoryName,
      pullRequestId,
      beforeCommitId,
      afterCommitId,
      filePath,
      line: issue.line,
      content: `${issue.icon} **${issue.type}**: ${issue.message}`
    });
    results.push(issueComment);
  }
  
  return results;
}

/**
 * Extract specific issues from AI analysis with line numbers
 */
function extractIssuesFromAnalysis(aiAnalysis, fileContent) {
  const issues = [];
  const lines = fileContent.split('\n');
  
  // Simple pattern matching for common issues
  const patterns = [
    { type: 'Security Issue', icon: '🔒', keywords: ['password', 'secret', 'api_key', 'token'] },
    { type: 'Code Quality', icon: '📝', keywords: ['TODO', 'FIXME', 'HACK'] },
    { type: 'Performance', icon: '⚡', keywords: ['sleep(', 'Thread.sleep', 'for('] }
  ];
  
  lines.forEach((line, index) => {
    for (const pattern of patterns) {
      if (pattern.keywords.some(keyword => line.toLowerCase().includes(keyword.toLowerCase()))) {
        issues.push({
          line: index + 1, // 1-based line numbering
          type: pattern.type,
          icon: pattern.icon,
          message: `Found ${pattern.keywords.find(k => line.toLowerCase().includes(k.toLowerCase()))} on this line`
        });
        break; // Only one issue per line
      }
    }
  });
  
  return issues;
}

/**
 * Check if commenting is enabled
 */
export function isCommentingEnabled() {
  return process.env.CODECOMMIT_COMMENTS_ENABLED !== 'false';
}
